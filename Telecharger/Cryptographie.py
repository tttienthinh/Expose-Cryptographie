# -*- coding: utf-8 -*-
"""Cryptographie.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BFb5CMJwijUhsHAyECveqfO36PPvT2_O

SHIFT + ENTRER pour exécuter la Cellule de code \\
TRAN-THUONG Tien-Thinh MP* Lycée Hoche \\
5 Janvier 2022

# Importation
"""

import random, hashlib, math
import sympy.ntheory as nt

"""# RSA

## Fonctions Utiles
"""

def pgcd(a, b):
    if a==0:
        return b
    else:
        return pgcd(b%a, a)

def exp(a, n, mod):
    a_ = (a*a)%mod
    if n==0:
        return 1
    elif n%2 == 1:
        return (a* exp(a_, n//2, mod)) % mod
    else:
        return exp(a_, n//2, mod) % mod

def c_bezout(a, b):
    if a==0:
        return 0, 1
    else:
        x, y = c_bezout(b%a, a)
        return y-(x*(b//a)), x

"""## Calculs des clés"""

def calcul_cles(p, q):
    n = p*q
    w = (p-1)*(q-1)

    e = random.randint(2, w)
    while pgcd(e, w)!=1:
        e = random.randint(2, w)

    d, _ = c_bezout(e, w)
    d = d % w
    return (
        (e, n), # clé publique
        (d, n)  # clé privée
    )

def chiffrer(m, e, n): # dechiffrer revient à chiffrer mais avec la clé (d, n)
    return exp(m, e, n) # (m**e) % n

"""## Test sur des chiffres"""

(e, n), (d, _) = calcul_cles(23, 17)
e, d, n

m = 123
m_chiffre = chiffrer(m, e, n)
print(m_chiffre)

print(chiffrer(m_chiffre, d, n))

"""## Test avec du TEXT"""

def list_vers_str(l):
    return "".join(l)

def ASCII(m):
    return [ord(x) for x in m]

def ASCII_rev(L):
    return list_vers_str([chr(x) for x in L])

def chiffrer_list(L, e, n):
    return [chiffrer(x, e, n) for x in L]

def chiffrer_message(m, e, n):
    L = ASCII(m)
    L_chiffre = chiffrer_list(L, e, n)
    m_chiffre = ASCII_rev(L_chiffre)
    return m_chiffre

message = "Hello World !"
m_chiffre = chiffrer_message(message, e, n)
print(m_chiffre)

print(chiffrer_message(m_chiffre, d, n)) # déchiffrage

"""## Signature"""

p = 1336960567662962283753869307762637651931440981
q = 75653091714058546859351538667868792577806729
print(nt.isprime(p), nt.isprime(q))

(e_BOB, n_BOB), (d_BOB, _) = calcul_cles(p, q)
print(f"{e_BOB}\n{d_BOB}\n{n_BOB}")

def H256(x):
    binaire = str(x).encode("ASCII")
    Hash_hex = hashlib.sha256(binaire).hexdigest()
    return int(Hash_hex, 16)

# m = "Hello World !"
m = "Hello World !"
print(m)
hash = H256(m)
print(hash)

hash_chiffre = chiffrer(hash, d_BOB, n_BOB)
print(hash_chiffre)

hash_dechiffre = chiffrer(hash_chiffre, e_BOB, n_BOB)
print(hash_dechiffre)

hash == hash_dechiffre

"""# Tests de primalité

## Méthode naïve (déterministe)
"""

def est_premier(n):
    for x in range(2, int(math.sqrt(n)+1)):
        if n%x == 0:
            return False
    return True
{i: est_premier(i) for i in range(2, 15)}

"""## Crible d'Erathostene (déterministe)"""

def erathostene(n):
    L = [i for i in range(n, 1, -1)] # [n, n-1, ..., 3, 2]
    resultat = []
    while L!=[]:
        p = L.pop()
        resultat.append(p)
        L = [x for x in L if x%p != 0]
    return resultat
erathostene(50)

# L = erathostene(500_000) # 1 minute 56 secondes
len(L) # 41538

print(erathostene(100))

"""## Test de Primalité de Fermat (probabiliste)
Pour la base 2, il a seulement 2183 faux positifs quand on teste jusqu'à, 25 milliards. \\
Jusqu'à 500 000 il n'y a eu que 13 faux positifs sur les 41 551 nombres premiers trouvés,
soit un taux de bonnes réponses de 99.969%.
"""

def test_fermat_PGP(p):
    if p in [2, 3, 5, 7]:
        return True
    for a in [2, 3, 5, 7]:
        if exp(a, (p-1), p) != 1:
            return False
    return True

def gen_fermat_PGP(n):
    return [p for p in range(2, n) if test_fermat_PGP(p)]

L_ = gen_fermat_PGP(500_000) # 5 secondes
print(len(L_))

print(f"Taux de bonnes réponses : {round(100*(1-(len(L_)-len(L))/len(L_)), 3)}%")

def test_fermat(p, k):
    if not test_fermat_PGP(p):
        return False
    for _ in range(k-4):
        a = random.randint(1, p-1)
        if exp(a, (p-1), p) != 1:
            return False
    return True

def gen_fermat(n, k):
    return [p for p in range(2, n) if test_fermat(p, k)]

L_ = gen_fermat(500_000, 54) # 25 secondes
len(L_)

def gen_list_fermat(maxi, n, k):
    L = []
    while len(L) < n:
        p = random.randint(2, maxi)
        if test_fermat(p, 100):
            L.append(p)
    return L
L = gen_list_fermat(random.getrandbits(256), 2, 54)
L

[nt.isprime(x) for x in L]

"""## Test de primalité de Miller-Rabin (probabiliste)"""

def calcul_d_s(n):
    if n%2 == 1:
        return n, 0 # = d, s
    else:
        d, s = calcul_d_s(n//2)
        return d, s+1

def test_MR(d, s, n):
    a = random.randint(1, n - 1)
    x = exp(a, d, n)
    if (x == 1 or x == n - 1):
        return True
    for i in range(s-1):
        x = (x * x) % n
        if (x == 1):
            return False
        if (x == n - 1):
            return True
    return False

def test_MR_kfois( n, k):
    d, s = calcul_d_s(n-1)
    for _ in range(k):
        if not test_MR(d, s, n):
            return False
    return True

def gen_list_MR(maxi, n, k):
    L = []
    while len(L) < n:
        p = random.randint(2, maxi)
        if test_MR_kfois(p, k):
            L.append(p)
    return L
L = gen_list_MR(random.getrandbits(256), 10, 10)
L

[nt.isprime(x) for x in L]

def gen_MR(n, k):
    return [p for p in range(2, n) if test_MR_kfois(p, k)]

L_ = gen_MR(500_000, 2) # 6 secondes
len(L_)

L_ = gen_MR(10_000_000, 2) # 2 minutes 22 secondes
len(L_) # 664587

L_ = gen_fermat(10_000_000, 6) # 2 minutes 20 secondes
len(L_) # 664630

"""# Algorithme de factorisation"""

def facto(n):
    if n == 1:
        return [1]
    elif test_MR_kfois(n, 10):
        return [n]
    for x in range(2, int(n**0.5)+1):
        if n % x == 0:
            return [x] + facto(n//x)
    return [n]
n = random.getrandbits(32)
print(f"La décomposition de {n} est {facto(n)}")






