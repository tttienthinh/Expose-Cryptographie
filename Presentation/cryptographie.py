# -*- coding: utf-8 -*-
"""Cryptographie.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BFb5CMJwijUhsHAyECveqfO36PPvT2_O

SHIFT + ENTRER pour exécuter la Cellule de code

# Importation
"""

import random, sys, json, hashlib, math
import sympy.ntheory as nt

"""# RSA

## Fonctions Utiles
"""

def pgcd(a, b):
    if a==0:
        return b
    else:
        return pgcd(b%a, a)

def exp(a, n, mod):
    a_ = (a*a)%mod
    if n==0:
        return 1
    elif n%2 == 1:
        return (a* exp(a_, n//2, mod)) % mod
    else:
        return exp(a_, n//2, mod) % mod

def c_bezout(a, b):
    if a==0:
        return 0, 1
    else:
        x, y = c_bezout(b%a, a)
        return y-(x*(b//a)), x

"""## Calculs des clés"""

def calcul_cles(p, q):
    n = p*q
    w = (p-1)*(q-1)

    e = random.randint(2, w)
    while pgcd(e, w)!=1:
        e = random.randint(2, w)
    
    d, _ = c_bezout(e, w)
    d = d % w
    return (
        (e, n), # clé publique
        (d, n)  # clé privée
    )

def chiffrer(m, e, n): # dechiffrer revient à chiffrer mais avec la clé (d, n)
    return exp(m, e, n) # (m**e) % n

"""## Test sur des chiffres"""

(e, n), (d, _) = calcul_cles(23, 17)
e, d, n

m = 123
m_chiffre = chiffrer(m, e, n)
m_chiffre

chiffrer(m_chiffre, d, n)

"""## Test avec du TEXT"""

def list_vers_str(l):
    return "".join(l)

def ASCII(m):
    return [ord(x) for x in m]

def ASCII_rev(L):
    return list_vers_str([chr(x) for x in L])

def chiffrer_list(L, e, n):
    return [chiffrer(x, e, n) for x in L]

def chiffrer_message(m, e, n):
    L = ASCII(m)
    L_chiffre = chiffrer_list(L, e, n)
    m_chiffre = ASCII_rev(L_chiffre)
    return m_chiffre

message = "Hello World !"
m_chiffre = chiffrer_message(message, e, n)
m_chiffre

chiffrer_message(m_chiffre, d, n) # déchiffrage

"""## Signature"""

p = 8949017760404478433660502120640172166331527020395781144347740356234111327237
q = 38290378838305098522902362305811701143775546488597621962754450314020740876921
nt.isprime(p), nt.isprime(q)

(e_BOB, n_BOB), (d_BOB, _) = calcul_cles(p, q)
e_BOB, d_BOB, n_BOB

def H256(x):
    binaire = str(x).encode("ASCII")
    Hash_hex = hashlib.sha256(binaire).hexdigest()
    return int(Hash_hex, 16)

m_chiffre = "Hello World !"
hash = H256(m_chiffre)
hash

hash_chiffre = chiffrer(hash, d_BOB, n_BOB)
hash_chiffre

hash_dechiffre = chiffrer(hash_chiffre, e_BOB, n_BOB)
hash_dechiffre

hash == hash_dechiffre

"""# Tests de primalité

## Méthode naïve (déterministe)
"""

def est_premier(n):
    for x in range(2, int(math.sqrt(n)+1)):
        if n%x == 0:
            return False
    return True
{i: est_premier(i) for i in range(2, 15)}

"""## Crible d'Erathostene (déterministe)"""

def erathostene(n):
    L = [i for i in range(n, 1, -1)] # [n, n-1, ..., 3, 2]
    resultat = []
    while L!=[]:
        p = L.pop()
        resultat.append(p)
        L = [x for x in L if x%p != 0]
    return resultat
erathostene(50)

"""## Test de Primalité de Fermat (probabiliste)"""

def test_fermat(p, k):
    for _ in range(k):
        a = random.randint(1, p-1)
        if exp(a, (p-1), p) != 1:
            return False
    return True

def gen_list_fermat(maxi, n, k):
    L = []
    while len(L) < n:
        p = random.randint(2, maxi)
        if test_fermat(p, 100):
            L.append(p)
    return L
L = gen_list_fermat(random.getrandbits(256), 2, 100)
L

[nt.isprime(x) for x in L]

"""## Test de primalité de Miller-Rabin (probabiliste)"""

def calcul_d_s(n):
    if n%2 == 1:
        return n, 0 # = d, s
    else:
        d, s = calcul_d_s(n//2)
        return d, s+1

def test_MR(d, s, n):
	a = 2 + random.randint(1, n - 4)
	x = exp(a, d, n)
	if (x == 1 or x == n - 1):
		return True
	for i in range(s-1):
		x = (x * x) % n
		if (x == 1):
			return False
		if (x == n - 1):
			return True
	return False

def test_MR_kfois( n, k):
	d, s = calcul_d_s(n-1)
	for _ in range(k):
		if not test_MR(d, s, n):
			return False
	return True

def gen_list_MR(maxi, n, k):
    L = []
    while len(L) < n:
        p = random.randint(2, maxi)
        if test_MR_kfois(p, k):
            L.append(p)
    return L
L = gen_list_MR(random.getrandbits(256), 10, 10)
L

[nt.isprime(x) for x in L]

"""# Algorithme de factorisation"""

def facto(n):
    if n == 1:
        return [1]
    elif test_MR_kfois(n, 10):
        return [n]
    for x in range(2, int(n**0.5)+1):
        if n % x == 0:
            return [x] + facto(n//x)
    return [n]
n = random.getrandbits(32)
print(f"La décomposition de {n} est {facto(n)}")